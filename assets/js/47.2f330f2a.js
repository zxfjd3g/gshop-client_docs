(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{407:function(t,a,n){"use strict";n.r(a);var e=n(40),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"day09"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day09"}},[t._v("#")]),t._v(" day09")]),t._v(" "),n("h2",{attrs:{id:"今日任务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#今日任务"}},[t._v("#")]),t._v(" 今日任务")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("支付\n路由组件懒加载\n图片懒加载\n")])])]),n("h2",{attrs:{id:"支付"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#支付"}},[t._v("#")]),t._v(" 支付")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("动态获取支付信息: 金额 + 二维码图片url (qrcode工具包)\n显示二维码图片: 利用element-ui\n\t实现element-ui的按需引入打包\n\t2种UI组件\n\t  标签组件  ==> 写对应的标签产生对应的界面效果   <el-pagination>\n\t  函数/对象组件  ==> 执行函数或调用对象的方法出现对应的效果\n\t理解对话框:   MessageBox() ==> MessageBox.alert() / MessageBox.confirm()\n\t  this.$msgbox(): 通用的显示对话框的函数\n\t  this.$alert(): $msgbox的包装函数, 专门用来显示alert框\n\t  this.$confirm(): $msgbox的包装函数, 专门用来显示confirm框\n\t\n确信框显示后\n\t点击确定:\n\t\t提示成功\n\t\t跳转到成功界面\n\t\t清除定时器\n\t点击取消\n\t\t提示出错\n\t\t清除定时器\n轮询订单状态: 每隔1s发请求获取订单的状态\n\t如果已支付\n\t\t跳转到成功界面\n\t\t提示成功\n\t\t关闭确定框\n\t\t清除定时器\n\t\t分发删除所有选中的购物车商品的异步action\n\t如果未支付: 继续\n\t请求失败: \n\t\t提示请求出错\n\t\t清除定时器\n")])])]),n("h2",{attrs:{id:"路由组件懒加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由组件懒加载"}},[t._v("#")]),t._v(" 路由组件懒加载")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("理解: \n\t当打包构建应用时，JS包会变得非常大，影响页面加载(尤其是首页)。\n\t如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问时才加载对应组件，这样就更加高效了\n编码: \n\tHome = () => import('@/pages/Home') // 通过动态引入路由组件实现对其进行单独打包\n分析: \n\timport(modulePath): 动态import引入模块, 被引入的模块会被单独打包\n\t组件配置的是一个函数, 函数中通过import动态加载模块并返回\n\t初始时函数不会执行, 第一次访问才会执行, 也就是说只有一次请求对应的路由路径才会请求加载单独打包的js\n")])])]),n("h2",{attrs:{id:"图片懒加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图片懒加载"}},[t._v("#")]),t._v(" 图片懒加载")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("理解:\n\t还没有加载得到目标图片时, 先显示loading图片\n\t在<img>进入可视范围才加载请求目标图片\n编码:\n\t使用vue-lazyload实现\n\t下载: npm install -S vue-lazyload\n\timport VueLazyload from 'vue-lazyload'\n\t// 配置vue的插件\n\tVue.use(VueLazyload, { // 内部自定义一个指令: lazy\n\t\t\tloading,  // 配置loading图片\n\t})\n\t<img v-lazy=\"goods.defaultImg\" />")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);