(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{396:function(n,t,a){"use strict";a.r(t);var e=a(40),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"day02"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#day02"}},[n._v("#")]),n._v(" day02")]),n._v(" "),a("h2",{attrs:{id:"今日任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#今日任务"}},[n._v("#")]),n._v(" 今日任务")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("1). Home组件及其子组件(静态)\n2). 后台接口与使用postman测试接口\n3). axios二次封装与接口请求函数封装\n4). 使用vuex管理组件状态数据\n5). TypeNav组件动态展现\n6). TypeNav纯前台(与用户)交互效果\n")])])]),a("h2",{attrs:{id:"home组件及其子组件-静态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#home组件及其子组件-静态"}},[n._v("#")]),n._v(" Home组件及其子组件(静态)")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("1). TypeNav: 3级分类导航\n2). ListContainer: 包含轮播列表的容器\n3). TodayRecommend: 今日推荐\n4). Rank: 排行\n5). Like: 猜你喜欢\n6). Floor: 楼层\n7). Brand: 品牌\n注意: 图片\n")])])]),a("h2",{attrs:{id:"后台接口与使用postman测试接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#后台接口与使用postman测试接口"}},[n._v("#")]),n._v(" 后台接口与使用postman测试接口")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("1). 启动 ===> 选择登陆==> cancel ===> 进入主界面\n2). 输入url/参数进行请求测试\n3). 注意post请求体参数需要指定为json格式(后台只支持json格式, 不支持urlencoding)\n4). 保存测试接口 ==> 后面可以反复使用\n")])])]),a("h2",{attrs:{id:"ajax与后台进行交互"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax与后台进行交互"}},[n._v("#")]),n._v(" ajax与后台进行交互")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("1). 下载依赖包: npm install axios nprogress\n\n2). axios的二次封装(axios本身就是对XHR原生ajax的封装)     面试必说\n\t1. 配置通用的基础路径和超时时间\n\t\taxios.create({\n\t\t\tbaseURL: '/api',\n\t\t\ttimeout: 20000\n\t\t})\n\t2. 显示请求进度条\n\t\t显示: 在请求拦截器回调中执行: NProgress.start()\n\t\t隐藏: 在请求完成后的成功或失败回调中执行: NProgress.done()\n\t3. 成功返回的不再是repsonse, 而直接是响应休数据: response.data\n\t\t在响应拦截器成功回调中: return response.data\n\t4. 统一处理请求错误, 具体请求可以选择处理或不处理\n\t\t在响应拦截器失败的回调中: 提法错误信息, 抛出error或返回失败的promise\n\n3). 接口请求函数模块\n    包含项目中所有接口对应的ajax请求函数\n    函数的返回值是promise, 函数内部调用ajax模块发请求\n    需要掌握一个技能: 根据接口文档, 定义接口请求函数\n\n4). 测试调用接口请求函数获取数据\n    出404错误\n        axios配置请求地址: /api/product/getBaseCategoryList\n        发请求所在的基础url: http://localhost:8080\n        http://localhost:8080/api/product/getBaseCategoryList(没有处理, 就404)\n        后台接口的地址: http://39.99.186.36/api/product/getBaseCategoryList(没有处理)\n    解决办法1: 使用CORS解决ajax请求跨域\n        给axios指定正确的地址: baseURL: http://39.99.186.36/api\n        这样ajax请求就跨域了: 服务器返回特别的响应头\n            Access-Control-Allow-Origin: http://localhost:8080\n            Access-Control-Allow-Credentials: true\n    解决办法2: 使用代理服务器   开发中用得比较多\n        配置代理服务器: \n            devServer: {\n              proxy: {\n                '/api': { // 只对请求路由以/api开头的请求进行代理转发\n                  target: 'http://39.99.186.36', // 转发的目标url\n                  changeOrigin: true // 支持跨域\n                }\n              }\n            },\n        配置baseURL: baseURL: '/api'\n")])])]),a("h2",{attrs:{id:"axios发请求内部流程-理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#axios发请求内部流程-理解"}},[n._v("#")]),n._v(" axios发请求内部流程(理解)")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("service.get('/xxx').then(\n\tresult => { // 接收到是响应拦截器成功回调返回的结果\n        \n    },\n    error => { // 接收到是响应拦截器失败回调抛出的error\n        \n    }\n)\n\nget内部执行\n\n    Promise.resolve(config)\n    .then((config) => {  // 请求拦截器\n        return config\n    })\n    .then((config) => { // 发异步ajax\n        return new Promise((resolve, reject) => {\n            根据config使用xhr发ajax请求\n\n            // 如果成功了, 创建response对象\n            resolve(response)\n            // 如果失败了, 创建error对象\n            reject(error)\n\n        })\n    })\n    .then(\n        (response) => { // 响应拦截器成功的回调\n            return response.data\n        },\n        (error) => {  // 响应拦截器失败的回调\n           throw error\n        }\n    )\n\n")])])]),a("h2",{attrs:{id:"使用vuex管理组件状态数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用vuex管理组件状态数据"}},[n._v("#")]),n._v(" 使用vuex管理组件状态数据")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[n._v("1) vuex用来做什么?\n    vuex用来管理多个组件共享的状态数据\n    从后台动态获取数据\n\n2) vuex的基本使用\n    store相关: index / state / mutations / actions / getters \n    注册store: vm中注册store  ==> 组件中通过$store得到store对象\n    组件:  通过$store来读取或更新vuex管理的state数据\n          也可以通过mapState() / mapGetters() / mapMutations() / mapActions()\n\n3) vuex的多模块编程的必要性\n    vuex单模块问题: 需要的管理状态数据比较多, 那对应的mutations/actions模块就会变得比较大\n        如果添加新的数据管理, 需要修改现在文件(不断向其添加内容) \n    vuex多模块编程: 对各个功能模块的数据分别进行管理, 这样更加具有扩展性\n    什么时候需要用vuex多模块编程?  需要vuex管理的数据比较多时使用\n\n4) 多模块编程的总state结构:\n    {\n        home:{\n            categoryList: [], // 分类列表\n            xxx: {},\n            yyy: 'atguigu'\n        }\n        user: {\n            userInfo: {}\n        }\n    }\n\n5) 针对三级分类使用vuex管理\n    api: reqCategoryList\n    vuex: home.js中编写\n        异步action: \n            调用接口请求函数发异步ajax请求\n            请求成功后, 取出数据, 提交给mutation保存\n        mutation: \n            根据接收的数据参数更新当前模块的state中的状态数据\n        state: {categoryList, ...}\n    组件:\n        分发异步action请求获取数据到state: 数据从接口===> vuex的state\n        读取vuex的state中的数据到组件的计算属性: 数据从vuex的state ===> 组件的计算属性\n        在模板中动态显示: 插值 / 指令\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);