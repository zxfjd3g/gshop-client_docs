(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{405:function(t,a,e){"use strict";e.r(a);var s=e(40),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"day06"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#day06"}},[t._v("#")]),t._v(" day06")]),t._v(" "),e("h2",{attrs:{id:"今日任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#今日任务"}},[t._v("#")]),t._v(" 今日任务")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("1). 加入购物车\n2). AddCartSuccess(添加购物车成功)路由组件\n3). ShopCart(购物车)路由组件\n\t1). 动态显示购物车列表\n\t2). 勾选/不勾选某个商品 / 改变某个购物项商品的勾选状态\n\t3). 全选或全不选\n\t4). 修改商品数量\n\t5). 删除某个商品\n\t6). 删除所有选中商品\n")])])]),e("h2",{attrs:{id:"加入购物车"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加入购物车"}},[t._v("#")]),t._v(" 加入购物车")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("api: reqAddToCart()\nvuex: addToCart()\ncomponent:\n\t收集数据\n\tdispatch()\n\t如果成功了, 跳转到成功的路由\n\t如果失败了, 提示\n")])])]),e("h2",{attrs:{id:"如何实现-dispatch异步action完成-成功-失败-后-再去做某些操作-提示-跳转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何实现-dispatch异步action完成-成功-失败-后-再去做某些操作-提示-跳转"}},[t._v("#")]),t._v(" 如何实现: dispatch异步action完成(成功/失败)后, 再去做某些操作(提示/跳转)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("方式一: 使用回调函数数据  (可以不写)\n\tcomponent:\n\t\tdispatch('addToCart', {callback: this.callback}) \n\t\tcallback(errorMsg) {// 根据errorMsg是否有值来做相应处理}\n\taction:\n\t\t发异步ajax请求\n\t\t如果成功了, 执行callback()\n\t\t如果失败了, 执行callback('错误提示文本')\n方式二: 利用dispatch()的返回值是promise\n\tasync函数执行的返回是promise, promise的结果由什么决定?\n\t\t函数体执行抛出了异常  ==> 失败, reason就是抛出的异常\n\t\t函数体执行返回一个失败的promise ==> 失败, reason就是返回的promise的reason\n\t\t函数体执行返回一个成功的promise ==> 成功, value就是返回的promise的value\n\t\t函数体执行返回其它任意值 ==> 成功, value就是返回的值\n\tdispatch()的返回值是promise, 就是异步action执行返回的promise\n\t\tcomponent:\n\t\t\tconst promise = dispatch('addToCart', {})\n\t\t\t如果promise是成功的, 做成功的处理    await后面\n\t\t\t如果promise是失败的, 做失败的处理    try...catch\n\t\taction:\n\t\t\t发异步ajax请\n\t\t\t请求操作失败抛出错误  ===> 请求操作失败时action的promise是失败的, 请求操作成功action的promise是成功的\n")])])]),e("h2",{attrs:{id:"addcartsuccess路由组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#addcartsuccess路由组件"}},[t._v("#")]),t._v(" AddCartSuccess路由组件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("使用本地的iconfont\n跳转路由携带数据:\n\tquery/params参数: 刷新数据还在, 不能携带对象数据\n\tvuex: 在跳转前保存到vuex的state中: 可以传递任意类型的数据, 刷新数据不在了\n\tsessionStorage与localStorage: 可以利用它们携带基本或对象类型数据, 刷新数据还存在\n")])])]),e("h2",{attrs:{id:"sessionstorage与localstorage的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sessionstorage与localstorage的区别"}},[t._v("#")]),t._v(" sessionStorage与localStorage的区别")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("相同点:\n\t都是window上的属性对象\n\t保存的数据刷新都存在\n\t语法: setItem(key, value)/getItem(key)/removeItem(key)/clear()  key是标识名称, value是json字符串\n\t都纯浏览器端的存储, 请求时不会自动携带(区别于cookie)\n不同点:\n\tlocalStorage: 数据保存在浏览器管理的本地文件中, 刷新或关闭浏览器, 数据依然还在\n\tsessionStorage: 数据保存在浏览器的运行内存中, 刷新浏览器数据还在, 但关闭浏览器数据不在(浏览器关闭后可能在后台运行)\n")])])]),e("h2",{attrs:{id:"显示购物车数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#显示购物车数据"}},[t._v("#")]),t._v(" 显示购物车数据")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("api: reqShopCart()\nvuex: shopCart.js:\n\tstate: cartList\n\tmutations:RECEIVE_CART_LIST()\n\tactions: getCartList()\n\tgetters: totalCount / totalPrice / isAllChecked\ncomponent:\n\tdispatch()\n\tmapState()\n\t模板\n问题: 请求获取不到购物列表数据\n疑问: 服务器端如何识别不同的浏览器\n解决: 通过用户临时ID的请求头标识\n")])])]),e("h2",{attrs:{id:"用户临时id"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用户临时id"}},[t._v("#")]),t._v(" 用户临时ID")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("作用: 用来标识某个浏览器客户端的唯一标识字符串  'b2f79046-7ee6-4dbf-88d0-725b1045460b'\n特点:\n\t不同的浏览器访问产生的值肯定不一样, 同一个浏览器多次产生也不样\n\t浏览器端生成, 并保存在浏览器端, 每次请求都会通过请求头来携带给服务器端\n\t服务器端保存购物车数据时是以它为标识保存\n创建:\n\t使用uuid/uuidjs工具库生成\n\timport { v4 as uuidv4 } from 'uuid';\n\tuuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'\n保存:\n\tlocalStorage: 以USER_TEMP_ID_KEY为key保存  ==> 关闭浏览/电脑后再打开数据依然存在\n\tvuex的state中: 保存到user模块中的userTempId状态中  ==> 不用多次从localStorage中读取\n使用:\n\t每个请求自动携带userTempId的请求头: 在请求拦截器中实现\n")])])]),e("h2",{attrs:{id:"勾选-不勾选某个商品-改变某个购物项商品的勾选状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#勾选-不勾选某个商品-改变某个购物项商品的勾选状态"}},[t._v("#")]),t._v(" 勾选/不勾选某个商品 / 改变某个购物项商品的勾选状态")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("api: reqCheckCartItem (skuId, isChecked)\n\tskuId: 商品的ID\n\tisChecked: 商品选中状态, '0'代表不选中, '1'代表选中\nvuex: checkCartItem({commit}, {skuId, isChecked})\ncomponent:\n\t在change事件回调中, 分发触发checkCartItem action调用  ===> 发请求\n\t如果失败了, 提示\n\t如果成功了, 重新获取购物车数据显示\n")])])]),e("h2",{attrs:{id:"全选或全选"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全选或全选"}},[t._v("#")]),t._v(" 全选或全选")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("api: 没有对应的接口, 得使用reqCheckCartItem(skuId, isChecked)\nvuex: checkAllCartItems(context, data)\n\t1). 需要对所有购物项与checked不一致的购物项发送请求\n\t2). 针对每个需要发请求的item去触发checkCartItem()调用  ===> 调用dispatch()\n\t3). context对象的结构:\n\t  {\n\t    state,      // 等同于 `store.state`，若在模块中则为局部状态\n\t    getters,    // 等同于 `store.getters`\n\t    commit,     // 等同于 `store.commit`\n\t    dispatch,   // 等同于 `store.dispatch`\n\t  }\n\t4). 执行多个请求的异步操作, 只有当都成功时, 整体异步action才成功, 否则失败\n\t  const promise = Promise.all([p1, p2, p3])\ncomponent:\n\t对应setter方法中, 分发触发checkAllCartItems action调用  ===> 发请求\n\t如果失败了, 提示\n\t如果成功了, 重新获取购物车数据显示\n")])])]),e("h2",{attrs:{id:"修改商品数量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#修改商品数量"}},[t._v("#")]),t._v(" 修改商品数量")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("api: reqAddToCart(skuId, skuNum)\n\tskuId: 商品ID\n\tskuNum: 商品数量, 正数代表增加, 负数代表减少\nvuex: \n\taddToCart({commit}, {skuId, skuNum})\ncomponent: \n\t绑定click与change事件\n\t在vue中和原生DOM中的input输入框\n        input事件: 输入改变时触发\n        change事件: 失去焦点改变才触发\n\t在change事件调用多输入了一个$event参数\n\t在事件回调函数分异步action发更新数量的请求\n\t对数量要进行判断限制\n")])])]),e("h2",{attrs:{id:"删除某个商品-独立完成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除某个商品-独立完成"}},[t._v("#")]),t._v(" 删除某个商品 (独立完成)")]),t._v(" "),e("h2",{attrs:{id:"删除所有选中商品-独立完成"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除所有选中商品-独立完成"}},[t._v("#")]),t._v(" 删除所有选中商品(独立完成)")]),t._v(" "),e("h2",{attrs:{id:"输入框的几个事件处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#输入框的几个事件处理"}},[t._v("#")]),t._v(" 输入框的几个事件处理")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('4个事件监听\n\tinput事件: 输入改变时触发\n\tkeyup事件: 按键起来时触发\n    change事件: 失去焦点且有改变时触发\n\tblur事件: 失去焦点时触发\n3种输入方式:\n\t键盘单字符输入\n\t通过 CTRL + C 粘贴输入\n\t通过 鼠标右键粘贴输入\n@input="validInput": \n  \t三种方式都能监听, 输入非法字符不会有输入变化, 粘贴时已自动去掉非法字符\n@keyup="validInput" \n  \t不能监视鼠标右键方式, 输入非法字符显示后再自动删除, 粘贴时显示后再自动删除非法字符\n通过正则限制输入\n\t目标: 将输入框中的开头的n个0或者n个非数字替换为空串\n\t正则: /^0+|\\D+0*/g : 匹配 开头的1+个0 或者 任意位置的1+个非数字及后面0+个0\n\t\t\\D 代表非数字 \n\t\t+ 代表个数>=1\n\t\t* 代表个数>=0\n\t\t? 代表0/1个\n\t\t| 或者\n\t\tg 找出所有匹配的\n\t测试文本: -0a011a0110  替换后变为 11110')])])])])}),[],!1,null,null,null);a.default=n.exports}}]);