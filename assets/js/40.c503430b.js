(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{396:function(t,a,n){"use strict";n.r(a);var e=n(40),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"day02"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#day02"}},[t._v("#")]),t._v(" day02")]),t._v(" "),n("h2",{attrs:{id:"今日任务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#今日任务"}},[t._v("#")]),t._v(" 今日任务")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1). Home组件及其子组件(静态)\n2). 后台接口与使用postman测试接口\n3). axios二次封装与接口请求函数封装\n4). 使用vuex管理组件状态数据\n5). TypeNav组件动态展现\n6). TypeNav纯前台(与用户)交互效果\n")])])]),n("h2",{attrs:{id:"home组件及其子组件-静态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#home组件及其子组件-静态"}},[t._v("#")]),t._v(" Home组件及其子组件(静态)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1). TypeNav: 3级分类导航\n2). ListContainer: 包含轮播列表的容器\n3). TodayRecommend: 今日推荐\n4). Rank: 排行\n5). Like: 猜你喜欢\n6). Floor: 楼层\n7). Brand: 品牌\n注意: 图片\n")])])]),n("h2",{attrs:{id:"后台接口与使用postman测试接口"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后台接口与使用postman测试接口"}},[t._v("#")]),t._v(" 后台接口与使用postman测试接口")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1). 启动 ===> 选择登陆==> cancel ===> 进入主界面\n2). 输入url/参数进行请求测试\n3). 注意post请求体参数需要指定为json格式(后台只支持json格式, 不支持urlencoding)\n4). 保存测试接口 ==> 后面可以反复使用\n")])])]),n("h2",{attrs:{id:"ajax与后台进行交互"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ajax与后台进行交互"}},[t._v("#")]),t._v(" ajax与后台进行交互")]),t._v(" "),n("p",[t._v("1). 下载依赖包: npm install axios nprogress")]),t._v(" "),n("p",[t._v("2). axios的二次封装(axios本身就是对XHR原生ajax的封装)     面试必说\n1). 封装通用的基础与超时时间")]),t._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[t._v("axios"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tbaseURL"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'/api'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\ttimeout"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("200000")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("p",[t._v("​\t2) 请求进度条效果: nprogress")]),t._v(" "),n("p",[t._v("​\t\t显示进度: 在请求拦截器中: NProgress.start()")]),t._v(" "),n("p",[t._v("​\t\t隐藏进度: 在响应拦截器成功和失败的回调中: NProgress.done()")]),t._v(" "),n("p",[t._v("​\t3) 请求成功得到不再是response, 而是response.data (响应体数据)")]),t._v(" "),n("p",[t._v("​\t\t在响应拦截器成功的回调中: return response.data")]),t._v(" "),n("p",[t._v("​\t4) 请求出错, 做统一的错误提示, 让特定请求还可以对错误做特定处理")]),t._v(" "),n("p",[t._v("​\t\t在响应拦截器失败的回调中:")]),t._v(" "),n("p",[t._v("​\t\t\t提示错误: alert(error.message)")]),t._v(" "),n("p",[t._v("​\t\t\t抛出error: throw error")]),t._v(" "),n("p",[t._v("3). 接口请求函数模块\n包含项目中所有接口对应的ajax请求函数\n函数的返回值是promise, 函数内部调用ajax模块发请求\n需要掌握一个技能: 根据接口文档, 定义接口请求函数")]),t._v(" "),n("p",[t._v("4). 测试调用接口请求函数获取数据\n出404错误\naxios配置请求地址: /api/product/getBaseCategoryList\n发请求所在的基础url: http://localhost:8080\nhttp://localhost:8080/api/product/getBaseCategoryList(没有处理, 就404)\n后台接口的地址: http://39.99.186.36/api/product/getBaseCategoryList(没有处理)\n解决办法1: 使用CORS解决ajax请求跨域\n给axios指定正确的地址: baseURL: http://39.99.186.36/api\n这样ajax请求就跨域了: 服务器返回特别的响应头\nAccess-Control-Allow-Origin: http://localhost:8080\nAccess-Control-Allow-Credentials: true\n解决办法2: 使用代理服务器   开发中用得比较多\n配置代理服务器:\ndevServer: {\n  proxy: {\n    '/api': { // 只对请求路由以/api开头的请求进行代理转发\n      target: 'http://39.99.186.36', // 转发的目标url\n      changeOrigin: true // 支持跨域\n    }\n  }\n},\n配置baseURL: baseURL: '/api'")]),t._v(" "),n("h2",{attrs:{id:"axios发请求内部流程-理解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#axios发请求内部流程-理解"}},[t._v("#")]),t._v(" axios发请求内部流程(理解)")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("service.get('/xxx').then(\n\tresult => { // 接收到是响应拦截器成功回调返回的结果\n        \n    },\n    error => { // 接收到是响应拦截器失败回调抛出的error\n        \n    }\n)\n\nget内部执行\n\n    Promise.resolve(config)\n    .then((config) => {  // 请求拦截器\n        return config\n    })\n    .then((config) => { // 发异步ajax\n        return new Promise((resolve, reject) => {\n            根据config使用xhr发ajax请求\n\n            // 如果成功了, 创建response对象\n            resolve(response)\n            // 如果失败了, 创建error对象\n            reject(error)\n\n        })\n    })\n    .then(\n        (response) => { // 响应拦截器成功的回调\n            return response.data\n        },\n        (error) => {  // 响应拦截器失败的回调\n           throw error\n        }\n    )\n\n")])])]),n("h2",{attrs:{id:"使用vuex管理组件状态数据"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用vuex管理组件状态数据"}},[t._v("#")]),t._v(" 使用vuex管理组件状态数据")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1) vuex用来做什么?\n    vuex用来管理多个组件共享的状态数据\n    从后台动态获取数据\n\n2) vuex的基本使用\n    store相关: index / state / mutations / actions / getters \n    注册store: vm中注册store  ==> 组件中通过$store得到store对象\n    组件:  通过$store来读取或更新vuex管理的state数据\n          也可以通过mapState() / mapGetters() / mapMutations() / mapActions()\n\n3) vuex的多模块编程的必要性\n    vuex单模块问题: 需要的管理状态数据比较多, 那对应的mutations/actions模块就会变得比较大\n        如果添加新的数据管理, 需要修改现在文件(不断向其添加内容) \n    vuex多模块编程: 对各个功能模块的数据分别进行管理, 这样更加具有扩展性\n    什么时候需要用vuex多模块编程?  需要vuex管理的数据比较多时使用\n\n4) 多模块编程的总state结构:\n    {\n        home:{\n            categoryList: [], // 分类列表\n            xxx: {},\n            yyy: 'atguigu'\n        }\n        user: {\n            userInfo: {}\n        }\n    }\n\n5) 针对三级分类使用vuex管理\n    api: reqCategoryList\n    vuex: home.js中编写\n        异步action: \n            调用接口请求函数发异步ajax请求\n            请求成功后, 取出数据, 提交给mutation保存\n        mutation: \n            根据接收的数据参数更新当前模块的state中的状态数据\n        state: {categoryList, ...}\n    组件:\n        分发异步action请求获取数据到state: 数据从接口===> vuex的state\n        读取vuex的state中的数据到组件的计算属性: 数据从vuex的state ===> 组件的计算属性\n        在模板中动态显示: 插值 / 指令\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);