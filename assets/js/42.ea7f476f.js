(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{400:function(a,t,e){"use strict";e.r(t);var r=e(40),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"day04"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#day04"}},[a._v("#")]),a._v(" day04")]),a._v(" "),e("h2",{attrs:{id:"今日任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#今日任务"}},[a._v("#")]),a._v(" 今日任务")]),a._v(" "),e("p",[a._v("1). Search组件动态显示\n2). 根据分类/关键字条件进行搜索\n3). 根据品牌进行搜索\n4). 根据平台属性进行搜索\n5). 排序搜索\n6). 响应式数据对象: 添加新属性和删除属性\n7). 自定义分页组件")]),a._v(" "),e("h2",{attrs:{id:"search静态组件和动态显示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#search静态组件和动态显示"}},[a._v("#")]),a._v(" Search静态组件和动态显示")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("api: reqProductList\nvuex: search.js---state/mutations/actions/getters\ncomponent: dispatch() / mapState() / 模板显示\n")])])]),e("h2",{attrs:{id:"调试时查看动态数据的位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#调试时查看动态数据的位置"}},[a._v("#")]),a._v(" 调试时查看动态数据的位置")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("vue: 组件---data/props/computed/vuex bindings\nvuex: state/getters/mutation调用\nnetwork: 请求---url/method/query/params/响应体\n")])])]),e("h2",{attrs:{id:"搜索商品分页列表数据的条件参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#搜索商品分页列表数据的条件参数"}},[a._v("#")]),a._v(" 搜索商品分页列表数据的条件参数")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("category1Id: '', // 一级分类ID\ncategory2Id: '', // 二级分类ID\ncategory3Id: '', // 三级分类ID\ncategoryName: '', // 分类名称\nkeyword: '', // 搜索关键字\n\ntrademark: '', // 品牌: \"ID:品牌名称\" \"1:苹果\"\nprops: [], // 商品属性的数组: [\"属性ID:属性值:属性名\"] [\"2:6.0～6.24英寸:屏幕尺寸\"]\norder: '1:desc', // 排序方式  1: 综合,2: 价格 asc: 升序,desc: 降序  \"1:desc\"\n\npageNo: 1, // 页码\npageSize: 5, //\t每页数量\n")])])]),e("h2",{attrs:{id:"使用已封装好的分页组件显示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用已封装好的分页组件显示"}},[a._v("#")]),a._v(" 使用已封装好的分页组件显示")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("vue自定义事件: 实现子组件向父组件通信\n子组件: 分发自定义事件: this.$emit('eventName', data)\n父组件: 给子组件对象绑定事件监听 @eventName=\"getProductList\", 并在回调函数中更新数据\n")])])]),e("h2",{attrs:{id:"根据分类-关键条件进行搜索"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#根据分类-关键条件进行搜索"}},[a._v("#")]),a._v(" 根据分类/关键条件进行搜索")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("分类条件数据: categoryName / category1Id / category2Id / category3Id\n关键字条件数据: keyword\n\n需要根据分类的query参数和关键字的params参数来搜索\n\t在created()中\n\t先根据query & params参数来更新options数据\n\t根据options数据发搜索的请求\n\n问题: 在搜索界面, 再通过点击分类或点击搜索跳转到搜索界面, 不会再发搜索的请求\n原因: 从A路由跳转到A路由, A路由组件对象不会重新创建(即使参数变化) ==> 不会再次调用初始勾子(created) ==> 没有发请求\n解决： 路由组件中如何监视路由参数数据变化?\n\t通过watch $route来监视路由参数的变化\n\t一旦路由参数变化了, 路由组件对象的$route属性值就是一个全新的\n\n显示分类条件和关键字条件\n删除分类条件和关键字条件\n\t重置相关数据\n\t重新请求获取数据\n\n问题: 删除分类和关键字条件后, 地址栏还有这些参数数据\n解决: 删除分类和关键字条件, 去掉对应的参数数据\n\t删除分类: 重新跳转到Search, 不携带query参数, 需要携带params\n\t删除关键字: 重新跳转到Search, 不携带params参数, 需要携带query\n\n问题: 删除关键字条件后, Header中输入框的关键字文本还在\n解决: 在删除关键字的回调中通知Header中删除输入框数据  ==> 兄弟组件间通信\n\t使用技术: 全局事件总线\n\t1). 将全局事件总线对象(vm)保存到Vue原型对象上\n\t2). 在Search中: 通过事件总线对象分发自定义事件\n\t3). 在Header中: 通过事件总线对象绑定自定义事件监听, 在回调中删除输入数据\n\n问题: 在搜索界面再次反复搜索后, 一次性回退不到home页  ==> 目标是一次回到Home\n原因: 从Search ==> Search我们现在用的是push()\n解决: 从Search ==> Search, 使用replace()\n")])])]),e("h2",{attrs:{id:"根据品牌进行搜索"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#根据品牌进行搜索"}},[a._v("#")]),a._v(" 根据品牌进行搜索")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('品牌数据的结构: trademark "ID:品牌名称" "1:苹果"\n子组件向父组件: 函数类型props\n限制: 如果点击的的品牌已经在条件中了, 不发请求\n')])])]),e("h2",{attrs:{id:"根据属性进行搜索"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#根据属性进行搜索"}},[a._v("#")]),a._v(" 根据属性进行搜索")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('属性数据的结构: props: [], // ["属性ID:属性值:属性名"] ["2:6.0～6.24英寸:屏幕尺寸"]\n添加属性条件:\n\t子组件向父组件: 自定义事件\n\t事件名: addProp\n\t数据: "属性ID:属性值:属性名"\n移除一个属性条件\n')])])]),e("h2",{attrs:{id:"排序搜索"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#排序搜索"}},[a._v("#")]),a._v(" 排序搜索")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("排序的数据结构: order: '1:desc', // 排序方式  1: 综合,2: 价格 asc: 升序,desc: 降序  \"1:desc\"\n\toderFlag: '1' / '2'\n\torderType: 'asc' / 'desc\n\torderFlag:orderType\n当前排序项? \n\t根据当前order的oderFlag来确定\n当前排序方式?\n\t根据当前order的orderType来确定\n点击排序项切换排序\n\t点击当前排序项: 切换排序方式(排序项不变)\n\t点击非当前排序项: 切换排序项, 排序方式为降序\n\n注意: 如果不想把模块中的表达写得太长: 需要定义对应的计算属性或者方法\n")])])]),e("h2",{attrs:{id:"响应式数据对象-添加新属性和删除属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应式数据对象-添加新属性和删除属性"}},[a._v("#")]),a._v(" 响应式数据对象: 添加新属性和删除属性")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("data或state中的所有层次的属性数据都是响应式的(属性值发生变化, 界面就会自动更新)\n响应式数据对象: data或state中对象类型的属性: 比如options\n给响应式数据对象添加新属性\n\t错误的写法：   不是响应式  ==> 不会自动更新界面\n\t\toptions.xxx = 'abc' \n\t正确的写法:  是响应式的 ==> 会自动更新界面\n\t\tVue.set( target, key, value )\n\t\tvm.$set( target, key, value )\n删除属性响应式数据对象的属性\n\t错误的写法：   \n\t\tdelete options.xxx   vue内部不知道, 界面不会自动更新\n\t正确的写法:  方法内部先删除属性, 再更新界面\n\t\tVue.delete( target, key )\n\t\tvm.$delete( target, key )\n")])])]),e("h2",{attrs:{id:"问题-优化减少没必要的请求参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-优化减少没必要的请求参数"}},[a._v("#")]),a._v(" 问题: 优化减少没必要的请求参数")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('原因: 当前的后台接口不需要空串参数或空数组参数\n解决: 在提交请求前, 将""参数和空数组的参数数据删除\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);