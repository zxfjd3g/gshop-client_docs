(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{405:function(t,e,a){"use strict";a.r(e);var n=a(40),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"day08"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#day08"}},[t._v("#")]),t._v(" day08")]),t._v(" "),a("h2",{attrs:{id:"今日任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#今日任务"}},[t._v("#")]),t._v(" 今日任务")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("订单与支付相关路由流程\n路由导航(跳转)守卫及其相关功能\n个人订单列表\n订单交易\n支付\n")])])]),a("h2",{attrs:{id:"订单与支付相关路由流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#订单与支付相关路由流程"}},[t._v("#")]),t._v(" 订单与支付相关路由流程")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("定义所有相关的路由组件==> 注册  ==> 通过声明式/编程式路由跳转关联\n什么时候需要定义子路由(二级)?  如果在一个大的路由界面上又有局部界面的切换显示\n")])])]),a("h2",{attrs:{id:"路由导航-跳转-守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由导航-跳转-守卫"}},[t._v("#")]),t._v(" 路由导航(跳转)守卫")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("路由导航(跳转)守卫是什么?\n\tvue-router提供的能监控(监视和控制)路由跳转的相关语法功能\n\n分类:  (应用开发中基本都是用前置守卫)\n\t全局守卫\n\t\t前置: 监视任意路由跳转, 在准备跳转到目标路由时回调\n\t\t\trouter.beforeEach((to, from, next) => {})\n\t\t\t\tto: 目标路由对象\n\t\t\t\tfrom: 当前路由对象  对应的就$route\n\t\t\t\tnext: 控制路由跳转的函数\n\t\t\t\t  不执行: 不放行, 不会跳转到目标路由\n\t\t\t\t  next(): 放行, 请求的路由组件才能显示\n\t\t\t\t  next(path): 强制跳转到指定路由去\n\t\t后置: 监视任意路由跳转, 在已经跳转到目标路由时才调用\n\t路由守卫\n\t\t前置: 监视是跳转到当前路由, 当准备跳转时回调\n\t\t\tbeforeEnter: (to, from, next) => { }\n\t组件守卫\n\t\t前置: 与路由前置守卫功能类似\n\t\t\tbeforeRouteEnter (to, from, next) {},\n\t\t\t\tnext((component) => {}) // 指定回调函数在组件对象创建之后执行\n\t\t更新: beforeRouteUpdate (to, from, next) \n\t\t离开: beforeRouteLeave (to, from, next)\n")])])]),a("h2",{attrs:{id:"导航守卫相关功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#导航守卫相关功能"}},[t._v("#")]),t._v(" 导航守卫相关功能")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("a.只有登陆了, 才能查看交易/支付/个人中心界面\nb.只有没有登陆, 才能查看登陆界面\nc.只有携带的skuNum以及sessionStorage中有skuInfo数据, 才能查看添加购物车成功的界面\nd.只能从购物车界面, 才能跳转到交易界面\ne.只能从交易界面, 才能跳转到支付界面\nf.只有从支付界面, 才能跳转到支付成功的界面\n")])])]),a("h2",{attrs:{id:"我的订单列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我的订单列表"}},[t._v("#")]),t._v(" 我的订单列表")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('api: reqOrders(page, limit)\ncomponent: \n\t如何直接能得到包含所有接口请求函数的对象? Vue.prototype.$API = API  ==> this.$API.reqOrder()\n\t将异步获取指定页码显示的代码封装成方法: getOrders(page=1)\n\t初始显示后动态显示第一页列表: 在mounted()中调用getOrders()\n\t分页组件Pagination绑定当前页码改变的监听: @currentChange="getOrders"\n\t列表中的某些列只显示一行: v-if="index===0"\n\t统一控制多个标签: <template v-if="index===0">包含多个标签\n\t使用一些的列占用多行的高度: :rowspan="list.length"\n')])])]),a("h2",{attrs:{id:"相关接口函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关接口函数"}},[t._v("#")]),t._v(" 相关接口函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("reqTradeInfo()\nreqSubmitOrder (tradeNo, orderInfo)\nreqPayInfo (orderId)\nreqPayStatus (orderId)\n")])])]),a("h2",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" vuex")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("order.js\nstate: tradeInfo / payInfo\nmutations: RECEIVE_TRADE_INFO() / RECEIVE_PAY_INFO()\nactions:  getTradeInfo() / getPayInfo()\n")])])]),a("h2",{attrs:{id:"订单交易"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#订单交易"}},[t._v("#")]),t._v(" 订单交易")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("动态获取交易信息显示\n选中收货地址功能\n\t默认选中的是默认的收货地址: 使用watch监视 'tradeInfo.userAddressList'\n\t点击指定某个收货地址\n提交订单\n\t收集数据\n\t调用接口请求函数发请求\n\t如果成功了, 跳转到支付路由并携带获取orderId\n\t如果失败, 提示\n")])])]),a("h2",{attrs:{id:"支付"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#支付"}},[t._v("#")]),t._v(" 支付")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("动态获取支付信息: 金额 + 二维码图片url (qrcode工具包)\n显示二维码图片: 利用element-ui\n\t实现element-ui的按需引入打包\n\t2种UI组件\n\t  标签组件  ==> 写对应的标签产生对应的界面效果   <el-pagination>\n\t  函数/对象组件  ==> 执行函数或调用对象的方法出现对应的效果\n\t理解对话框:   MessageBox() ==> MessageBox.alert() / MessageBox.confirm()\n\t  this.$msgbox(): 通用的显示对话框的函数\n\t  this.$alert(): $msgbox的包装函数, 专门用来显示alert框\n\t  this.$confirm(): $msgbox的包装函数, 专门用来显示confirm框\n\t\n\n确信框显示后\n\t点击确定:\n\t\t提示成功\n\t\t跳转到成功界面\n\t\t清除定时器\n\t点击取消\n\t\t提示出错\n\t\t清除定时器\n轮询订单状态: 每隔1s发请求获取订单的状态\n\t如果已支付\n\t\t跳转到成功界面\n\t\t提示成功\n\t\t关闭对话\n\t\t清除定时器\n\t\t分发删除所有选中的购物车商品的异步action\n\t如果未支付: 继续\n\t请求失败: \n\t\t提示请求出错\n\t\t清除定时器")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);