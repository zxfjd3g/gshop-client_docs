(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{399:function(a,t,e){"use strict";e.r(t);var s=e(40),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"day03"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#day03"}},[a._v("#")]),a._v(" day03")]),a._v(" "),e("h2",{attrs:{id:"今日任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#今日任务"}},[a._v("#")]),a._v(" 今日任务")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1). TypeNav的交互(与用户)效果\n2). mock数据接口\n3). 使用vuex管理mock接口返回的banners与floors数据\n4). 根据mock的接口实现动态ListContainer与Floor组件\n5). 抽取一个轮播组件Carousel\n6). 自己mock一下今日推荐的接口并动态显示(自己独立完成)\n")])])]),e("h2",{attrs:{id:"typenav的交互-与用户-效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typenav的交互-与用户-效果"}},[a._v("#")]),a._v(" TypeNav的交互(与用户)效果")]),a._v(" "),e("h3",{attrs:{id:"事件控制二三级分类列表的显示与隐藏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件控制二三级分类列表的显示与隐藏"}},[a._v("#")]),a._v(" 事件控制二三级分类列表的显示与隐藏")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("设计状态数据: currentIndex: 标识哪个下标的分类项需要显示子分类列表 \n定义显示子分类的样式类名: item_on\n绑定事件监听, 更新状态数据currentIndex\n\tmouseenter: 在每个分类项上, currentIndex更新为对应的下标\n\tmouseleave: 给包含h2和分类div的父元素绑定监听, 但又不能包含<nav> ==> 需要修改页面结构\n\t\t\t\t更新currentIndex为-1\n")])])]),e("h3",{attrs:{id:"优化高频事件触发处理-利用lodash进行函数节流处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化高频事件触发处理-利用lodash进行函数节流处理"}},[a._v("#")]),a._v(" 优化高频事件触发处理: 利用lodash进行函数节流处理")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("问题: 在快速滑动时, mouseenter事件高频触发, 导致currentIndex高频更新  ===> 界面在高频更新(不必要)\n解决: 利用lodash库的throttle来进行函数节流处理\n")])])]),e("h3",{attrs:{id:"优化减小打包文件-对lodash库实现按需引入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化减小打包文件-对lodash库实现按需引入"}},[a._v("#")]),a._v(" 优化减小打包文件: 对lodash库实现按需引入")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("问题: import _ from 'lodash'  // 引入整个lodash为, 还没有使用的工具函数也被打包了\n解决: import throttle from 'lodash/throttle' // 只引入需要的工具函数 ==> 打包文件变小了\n")])])]),e("h3",{attrs:{id:"解决快速移出后可能显示第一个分类的子分类列表的bug"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决快速移出后可能显示第一个分类的子分类列表的bug"}},[a._v("#")]),a._v(" 解决快速移出后可能显示第一个分类的子分类列表的bug")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("原因: 在进入第一个分类项后0.2s才真正更新currentIndex为0\n\t但在0.2s内, 已经移出了整体div\n解决: 设计currentIndex有3种值\n\t-2: 出了整个div\n\t-1: 进入了整个div, 但还没有进入分类项上\n\t>=0: 光标在某个分类项上(只有当不为-2才更新)\n")])])]),e("h3",{attrs:{id:"优化减少组件对象数量-使用编程式导航代替声明式导航"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化减少组件对象数量-使用编程式导航代替声明式导航"}},[a._v("#")]),a._v(" 优化减少组件对象数量: 使用编程式导航代替声明式导航")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("需求: 点击某个分类项, 跳转到Search路由, 并携带categoryName & category1Id/category2Id/category3Id\n实现: 使用声明路由导航<router-link>\n问题: 每个分类都要创建一个RouterLink组件对象(非常多), 显示缓慢\n解决: 使用编程式路由导航, 不用创建RouterLink组件对象, 显示更快  \n\t绑定点击监听, 在回调函数中通过push()/replace()来跳转\n")])])]),e("h3",{attrs:{id:"优化事件处理效率-利用事件委托"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化事件处理效率-利用事件委托"}},[a._v("#")]),a._v(" 优化事件处理效率: 利用事件委托")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("问题: 每个分类项都需要绑定点击监听, 监听数量太多了, 效率不高\n解决: 利用事件委托, 绑定一个点击监听来搞定所有分类项的点击响应\n")])])]),e("h3",{attrs:{id:"利用标签自定义属性携带动态数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#利用标签自定义属性携带动态数据"}},[a._v("#")]),a._v(" 利用标签自定义属性携带动态数据")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('问题: 如何得到对应的分类项的数据\n解决: 利用标签的data自定义属性 (H5的语法)\n\t给a标签指定data自定义属性: <a :data-categoryName="c1.categoryName">\n\t在事件回调函数读取data自定义属性值: const {categoryname} = event.target.dataset\n')])])]),e("h3",{attrs:{id:"控制一级列表的显示与隐藏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制一级列表的显示与隐藏"}},[a._v("#")]),a._v(" 控制一级列表的显示与隐藏")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("设计状态数据: isShowFirst\n初始值: 只有当是home路由时显示, 其它是隐藏\n什么时候更新为true: 当光标进入包含大标题和分类的div\n什么时候更新为false: 移出大的div / 点击了分类项后\n")])])]),e("h3",{attrs:{id:"一级列表显示隐藏的过渡效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一级列表显示隐藏的过渡效果"}},[a._v("#")]),a._v(" 一级列表显示隐藏的过渡效果")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('给显示隐藏的元素包上一个<transition name="xxx">\n在显示/隐藏过程的类名下指定: transition样式\n在隐藏时的类名下指定: 隐藏的样式\n')])])]),e("h3",{attrs:{id:"优化请求执行的位置-减少请求次数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化请求执行的位置-减少请求次数"}},[a._v("#")]),a._v(" 优化请求执行的位置, 减少请求次数")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("问题: 从首页跳转到搜索页, 还会请求三级分类列表\n原因: 在TypeNav组件的mount()中分发给异步action请求的 ==> 每个TypeNav组件对象都会发请求\n解决: 在App的mounted中去dispatch给异步action请求获取分类列表\n")])])]),e("h3",{attrs:{id:"合并分类query参数与搜索的关键字params参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#合并分类query参数与搜索的关键字params参数"}},[a._v("#")]),a._v(" 合并分类query参数与搜索的关键字params参数")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("问题: \n\t当根据分类跳转search时, 丢了keyword的params参数\n\t当根据keyword跳转search时, 丢了categoryName/cateory1Id/cateory2Id/cateory3Id的query参数\n解决:\n\t当根据分类跳转search时, 同时携带上keyword的params参数\n\t当根据keyword跳转search时,携带上catgoreyName/cateory1Id/cateory2Id/cateory3Id的query参数\n")])])]),e("h2",{attrs:{id:"mock数据接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mock数据接口"}},[a._v("#")]),a._v(" mock数据接口")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("问题: 当前首页只有分类的接口写好, 其它数据的接口还没有写好\n解决: 前端工程师自己mock/模拟接口数据\n")])])]),e("h2",{attrs:{id:"理解json数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理解json数据"}},[a._v("#")]),a._v(" 理解JSON数据")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("a.结构: 名称, 数据类型  ==> 用于读取数据值\nb.value: 会显示到界面上\nc.真实接口返回的数据与mock的数据的关系: value可以变, 但结构不能变\n注意: 如果有变化 ==> 需要修改模板中读取显示的代码  ==> 真实情况是多少会有些不同, 变化越小需要修改的代码就越少\n")])])]),e("h2",{attrs:{id:"使用mockjs来mock接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用mockjs来mock接口"}},[a._v("#")]),a._v(" 使用mockjs来mock接口")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("下载mockjs, 引入使用\nmockjs: 生成随机数据，拦截 Ajax 请求, 返回生成的随机数据\n定义mock json数据: 使用mockjs的随机语法\nmockServer中: 通过Mock.mock()来定义mock接口\nmain.js中: 引入mockServer\najax请求访问:\n\tapi/mockAjax中: 封装针对mock接口的axios封装封装\n\tapi/index中: 定义对应的接口请求函数\n\t组件中: 调用接口请求函数\n")])])]),e("h2",{attrs:{id:"使用vuex管理mock接口返回的banners与floors数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用vuex管理mock接口返回的banners与floors数据"}},[a._v("#")]),a._v(" 使用vuex管理mock接口返回的banners与floors数据")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("state: banners / floors\nmutation: RECEIVE_BANNERS() / RECEIVE_FLOORS()\naction: getBanners() / getFloors()\n")])])]),e("h2",{attrs:{id:"实现静态组件的swiper效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现静态组件的swiper效果"}},[a._v("#")]),a._v(" 实现静态组件的swiper效果")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("下载swiper\n引入: js/css\n模板页面: 层次结构与类名\n创建一个swiper对象并配置:  必须在轮播列表显示之后创建才有效  ==> 在mounted()中 \n")])])]),e("h2",{attrs:{id:"问题-为广告轮播创建的swiper对象也影响到了楼层的轮播页面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-为广告轮播创建的swiper对象也影响到了楼层的轮播页面"}},[a._v("#")]),a._v(" 问题: 为广告轮播创建的swiper对象也影响到了楼层的轮播页面")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("原因: new Swiper('.swiper-container'), 类名选择器也匹配了楼层的轮播页面 ==> 也产生了轮播的效果\n解决: 使用vue的ref技术 new Swiper(this.$refs.swiper) ===> 不会再影响到其它组件的轮播页面\n")])])]),e("h2",{attrs:{id:"listcontainer与floor组件动态展现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#listcontainer与floor组件动态展现"}},[a._v("#")]),a._v(" ListContainer与Floor组件动态展现")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("api: \n\treqBanners()\n\treqFloors()\nvuex: \n\tbanners / floors\n\tgetBanners() / getFloors()\n组件:\n\tdispatch()\n\tmapState()\n\t模板中显示\n")])])]),e("h2",{attrs:{id:"问题-动态组件轮播有问题-没有轮播效果"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-动态组件轮播有问题-没有轮播效果"}},[a._v("#")]),a._v(" 问题: 动态组件轮播有问题(没有轮播效果)")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("原因: 创建swiper对象的时间太早(在列表显示之前)\n解决:  在列表显示之后创建swiper对象\n\t办法一: 使用setTimeout延迟执行  ==> 不合适(因为请求获取数据的时间不确定)\n\t办法二: watch + nextTick()\n\t\twatch的回调: 在数据发生改变后执行(banners有数据了)\n\t\tnextTick(callback): 这次数据改变对应界面更新已经完成\n\t\t\n\t理解: 更新数据 / 调用监视的回调 / 更新界面 的流程\n\t\t我们更新数据 ==> vue自动调用监视的回调(界面还没更新) ==> vue自动更新界面\n\n\t理解: nextTick()\n\t\t2个API: Vue.nextTick( callback )\n\t\t\t\tvm.$nextTick( callback )\n\t\t我们什么时候调用nextTick()? 在数据更新之后, 界面更新之前\n\t\tVue什么时候回调callback? 在界面更新后执行\n")])])]),e("h2",{attrs:{id:"抽取轮播组件-carousel"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽取轮播组件-carousel"}},[a._v("#")]),a._v(" 抽取轮播组件: Carousel")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("声明接收属性: props: carouselList /autoplay\n模板: 根据接收的carouselList显示轮播列表\n创建Swiper对象: watch + nextTick()\n")])])]),e("h2",{attrs:{id:"问题-listainer中的轮播没有问题-但2个floor的轮播不可以"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题-listainer中的轮播没有问题-但2个floor的轮播不可以"}},[a._v("#")]),a._v(" 问题: Listainer中的轮播没有问题, 但2个Floor的轮播不可以")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('原因: \n\t基础理解: \n\t\t给组件标签传入的属性值是undefined/空数组, 组件对象会创建\n\t\t如果组件标签的v-for遍历的值是undefined/空数组, 组件对象不会创建\n\t\twatch的回调默认什么时候调用: 在监视的数据发生改变时才调用, 初始显示时不调用\n\t得到结果:\n\t\tbanners对应的<Carsoursel>有经历数据更新的过程 ===> 调用监视回调  ==> 创建swiper对象\n\t\tfloors对应的2个<Caroursel>没有经历数据更新的过程 ==> 没有调用监视回调  ==> 不会创建swiper对象\n\t详细过程:\n\t\t<ListContainer />\n\t\t\t<Carousel :carouselList="banners"/>\n\t\tbanners的变化: \n\t\t\t[] ===> [...]\n\t\t\t创建Carousel组件对象 ==> 更新组件对象 ==> 调用监视回调创建Swiper对象\n\n\t\t<Floor v-for="floor in floors" :key="floor.id" :floor="floor"/>\n\t\t\t<Carousel :carouselList="floor.carouselList"/>\n\t\tfloors的变化: \n\t\t\t[] ===> [{carouselList: []}, {carouselList: []}]\n\t\t\t不创建Carousel组件对象  ==> 创建Carousel组件对象 ==> 不会调用监视的回调\n\t\t\n解决:\n\t办法1: 给watch添加immediate配置, 让监视回调在初始时就会执行一次, 只有当有数据时才创建\n\t办法2: 如果初始时已经有数据了, 就创建一个对应的swiper对象\n')])])]),e("h2",{attrs:{id:"组件对象是否创建相关的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件对象是否创建相关的情况"}},[a._v("#")]),a._v(" 组件对象是否创建相关的情况")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('a = []\nb = undefined\n<T :a="a">  会创建组件对象  属性值是多少完全不影响组件对象的创建\n<T v-for="item in a"> 不会创建  只有数组中有元素时才会创建\n<T v-if="a"> 会创建  []转换为boolean是true   只有是true才会创建, fale不创建\n<T v-if="b"> 不会创建 undefined转换为boolean是false\n<T v-show="b"> 会创建, 只是通过样式来隐藏组件对象对应的界面   无论是true/false都会创建\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);